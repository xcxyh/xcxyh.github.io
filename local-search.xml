<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>马服如此恶心，如何玩上韩服DNF？</title>
    <link href="/2024/06/30/%E9%A9%AC%E6%9C%8D%E5%A6%82%E6%AD%A4%E6%81%B6%E5%BF%83%EF%BC%8C%E5%A6%82%E4%BD%95%E7%8E%A9%E4%B8%8A%E9%9F%A9%E6%9C%8DDNF%EF%BC%9F/"/>
    <url>/2024/06/30/%E9%A9%AC%E6%9C%8D%E5%A6%82%E6%AD%A4%E6%81%B6%E5%BF%83%EF%BC%8C%E5%A6%82%E4%BD%95%E7%8E%A9%E4%B8%8A%E9%9F%A9%E6%9C%8DDNF%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106765.jpeg" alt="选角色界面"></p><p>最近，国服 DNF 上线，非常火爆，想玩玩看韩服是什么样子的，由于国内环境问题，想玩上韩服DNF 还是要费上一番功夫的。这里记录下 Android 设备是怎么下载DNF 游戏安装包以及注册 韩服 DNF 账号的。</p><p>首先，需要创建一个未绑定任何地区的 google 账号。</p><p>账号注册需要海外手机号，这里使用 wild card 海外手机号 接收注册验证码的功能。指路：<a href="https://wildcard.com.cn/sms">WildCard | 一分钟注册，轻松订阅海外软件服务</a></p><p>注册完成之后，这里，你需要 一个 有 google 三件套 的 android 手机。进入到 google play app，登录刚才 注册的 账号。然后切换到 韩国地区。</p><p>切换到韩国地区的具体方式：</p><ol><li>首先，科学上网选择韩国节点。</li><li>然后清空 google play app 所有数据。</li><li>然后登录刚才注册的账号。</li><li>不要绑定任何信用卡， 一旦绑定就锁区了，就切换不到韩国地区的 应用商店了。</li></ol><p>例如, 想要切换到 韩国地区,下载 DNF 手游：</p><p>第一步, 注册一个全新的 google 账号,</p><p>第二步 , 连接好 韩国节点代理</p><p>第三步,清空 google play store 的app 所有数据,</p><p>第四步,登录google 账号.</p><p>即可搜到 韩国地区的游戏了.</p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106441.jpeg" alt="Google Play App 清空数据" width="300"><p>DNF 在 韩国地区 为 19+ 游戏, 需要 韩国 id 进行实名认证 才可以下载. 或者 下载 DNF 12+ 未成年版本.</p><p>这里，我们直接下载 12+ 版本，或者 你去某宝上买个 id ，认证后下载 19+ 的版本，这两个版本的主要区别是 交易行的限制，其他没区别，而且账号是互通的。体验韩服，下载 12+版本就行了。</p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106929.jpeg" alt="韩服地下城" width="300"><p>登录时，选择使用 google 账号登录。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106834.png" alt="Google 登录"></p><p>这里 下载完成之后，会遇到一个恶心的问题：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106383.png" alt="非法应用"></p><p>这时需要 在 权限设置中，禁用掉 dnf app 获取 手机应用列表的权限：</p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302107272.jpeg" alt="禁用权限" width="300"><p>完成以上步骤之后，连接好 韩国节点，打开 DNF，就可以愉快的游戏了。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106508.jpeg" alt="游戏界面"></p>]]></content>
    
    
    <categories>
      
      <category>工作之外</category>
      
    </categories>
    
    
    <tags>
      
      <tag>账号问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Keyboard 高度监听实践</title>
    <link href="/2024/06/30/Android-Keyboard-%E9%AB%98%E5%BA%A6%E7%9B%91%E5%90%AC%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/06/30/Android-Keyboard-%E9%AB%98%E5%BA%A6%E7%9B%91%E5%90%AC%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>最近遇到一个需求，需要输入框布局附着在软键盘上面，随着软键盘的上移下移动画而移动。要做到这一点，需要监听键盘的高度，而且最好是在键盘弹起的时候，每一帧都有一个高度的回调，这样，我们监听键盘高度的变化，对我们的输入框布局做transY动画 ，即可实现 输入框附着在键盘之上随之上下移动的动画效果了。</p><p>想要实现的效果：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302022019.gif" alt="效果图"></p><p>但是，经过对android 键盘高度监听相关方法的了解，发现事情并没有那么简单。</p><p>Android 监听键盘高度 非常复杂。而且，有多种方式可以实现，并且对于不同的 Android 版本，其实现方式也各不相同。而且，由于Android 机型、版本众多，来自不同品牌、不同类型、不同版本的android  手机，相同的代码可能有不同的表现。</p><p>在很早之前，大家都是用 getViewTreeObserver().addOnGlobalLayoutListener  拿到Activity的ContentView，设置<code>contentView.getViewTreeObserver()                 .addOnGlobalLayoutListener(onGlobalLayoutListener);</code></p><p>然后在监听内部再通过 <code>decorView.getWindowVisibleDisplayFrame</code>来获取显示的Rect，再通过 <code>decorView.getBottom() - outRect.bottom</code>的方式来获取高度。或者是 通过 添加一个宽度为0，高度撑满全屏的 PopupWindow 的骚操作来获取键盘的高度，让软键盘弹起的时候，计算PopopWindow移动了多少范围，从而计算软键盘的高度。而其中的关键就是当输入法弹出时， 它会把之前我们创建的那个看不见的弹窗往上挤， 这样我们创建的那个弹窗的位置就变化了，只要获取它底部高度的变化值就可以间接的获取输入法的高度了。</p><p>下面，简单介绍下，在 android 中 ，获取键盘高度的最新方式。在 Android R （Android 11 ，API 30）版本中，提供了 WindowInsets 相关API，新增了<code>WindowInsetsAnimation.Callback</code> 回调方法。 </p><p>什么是 Insets？</p><p>屏幕上除了开发者 app 绘制的内容还有系统的 Insets（嵌入物），Insets 区域负责描述屏幕的哪些部分会与系统 UI 相交。例如导航或状态栏。</p><p>常见的 Insets 有：</p><ul><li><code>STATUS_BAR</code>，用于展示系统时间，电量，wifi 等信息</li><li><code>NAVIGATION_BAR</code>，虚拟导航栏（区别于实体的三大金刚键），形态有三大金刚键导航，手势导航两种。（有些设备形态如 TV 没有导航栏）</li><li><code>IME</code>，软键盘，用于输入文字</li></ul><p>如果绘制的内容出现在了系统 UI 区域内，就可能出现视觉与手势的冲突。可以借助 Insets 把 view 从屏幕边缘向内移动到一个合适的位置。为了防止 App 内容区域与 <code>System bar</code>发生视觉冲突，官方提供了两种 API，<code>WidowInsets</code> 与  <code>fitsSystemWindows</code>。</p><p><strong><code>WidowInsets</code></strong> </p><p><strong>可以通过在自定义 View 中重写 <code>onApplyWindowInsets()</code> 方法或调用 <code>setOnApplyWindowInsetsListener()</code> 来监听 <code>WindowInsets</code> 的变化，通过对 View 添加 <code>margin</code> 或 <code>padding</code> 的方式处理解决冲突</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">editText.setOnApplyWindowInsetsListener(<span class="hljs-keyword">object</span> : View.OnApplyWindowInsetsListener &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onApplyWindowInsets</span><span class="hljs-params">(v: <span class="hljs-type">View</span>, insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets &#123;<br>                <span class="hljs-keyword">val</span> statusBar = insets.getInsets(WindowInsets.Type.statusBars())<br>                <span class="hljs-keyword">val</span> navBars = insets.getInsets(WindowInsets.Type.navigationBars())<br>                Log.i(<span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;status bar: <span class="hljs-subst">$&#123;statusBar.bottom&#125;</span>, nav bar: <span class="hljs-subst">$&#123;navBars.bottom&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span> insets<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><p>如何使用  window insets：( 版本 ≥ API 21 均可使用，windowInsetsCompat则为其兼容版本)</p><ol><li>使用 <code>ViewCompat.getRootWindowInsets(view)</code> 获取 <code>WindowInsets</code></li><li>通过 <code>WindowInsets#getInsets(type)</code> 获取 Insets</li><li>通过 Insets.top 或 Insets.bottom 获取 <code>System bar</code> 高度</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> windowInsetsCompat = ViewCompat.getRootWindowInsets(editText)<br><span class="hljs-keyword">val</span> ime = windowInsetsCompat?.getInsets(WindowInsetsCompat.Type.ime())<br><span class="hljs-keyword">val</span> height = ime?.bottom<br></code></pre></td></tr></table></figure><p><strong><code>fitsSystemWindows</code></strong></p><p><strong><code>SetFitsSystemWindows</code></strong> 是 View 中 API 14 后加入的方法，对应的 xml 属性是 <strong><code>android:fitsSystemWindows</code></strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:app=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    **android:fitsSystemWindows=<span class="hljs-string">&quot;true&quot;</span>**<br>    tools:context=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;<br>&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;<br></code></pre></td></tr></table></figure><p><strong><code>FitsSystemWindows</code> 的默认行为是：通过 padding 为 <code>System bar</code> 预留出空间。</strong></p><p>关于 <code>fitsSystemWindows</code>：</p><ul><li><code>fitsSystemWindows</code> 是深度优先（我们可以将视图树看成一个 N叉树）的，第一个设置 <code>fitsSystemWindows</code> 的 view 会去消费 insets 并影响视觉。</li><li>开发者在 xml 或 view 初始化设置的 padding 会被<strong>覆盖。</strong></li><li><a href="https://link.juejin.cn/?target=https://developer.android.com/reference/com/google/android/material/appbar/AppBarLayout.html">AppBarLayout</a>，<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/androidx/coordinatorlayout/widget/CoordinatorLayout.html">CoordinatorLayout</a>，<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/androidx/drawerlayout/widget/DrawerLayout.html">DrawerLayout</a> 等 view 会自定义 <code>fitsSystemWindows</code> 的行为。</li></ul><p>有了以上背景知识之后，我们来看如何使用 window insets 来监听键盘高度，首先，设置 setDecorFitsSystemWindows 为 false，来让内容区域全屏，然后去掉 android:fitsSystemWindows&#x3D;”true” （一定要去掉该属性）。设置完该属性后，发现下方内容都被系统的 nav bar 挡住了，出现了视觉冲突。可以使用以下代码来解决内容被系统bar 覆盖的问题。</p><p>首先设置 bar 为透明，然后，通过 setOnApplyWindowInsetsListener 来获取 window insets，获取系统bar 的高度之后，设置相应的padding。</p><p><strong>实现 边到边 (edge-to-edge) 沉浸式效果，并设置对应padding，不让系统bar 遮挡view内容。</strong></p><p>Android R 版本及以上的实现方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1. 使内容区域全屏</span><br>window.setDecorFitsSystemWindows(<span class="hljs-literal">false</span>)<br> <span class="hljs-comment">// 2. 设置 System bar 透明</span><br>window.statusBarColor = Color.TRANSPARENT<br>window.navigationBarColor = Color.TRANSPARENT<br><span class="hljs-keyword">val</span> rootView = findViewById&lt;View&gt;(R.id.root_container)<br>rootView.setOnApplyWindowInsetsListener &#123; v, insets -&gt;<br><span class="hljs-keyword">val</span> systemBars = insets.getInsets(WindowInsets.Type.systemBars())<br>  <span class="hljs-comment">// 此处更改的 margin，也可设置 padding，视情况而定</span><br>  rootView.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; &#123;<br>     topMargin = systemBars.top<br>     leftMargin = systemBars.left<br>     bottomMargin = systemBars.bottom<br>     rightMargin = systemBars.right<br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-symbol">@setOnApplyWindowInsetsListener</span> insets<br>&#125;<br></code></pre></td></tr></table></figure><p>然后 设置 <code>WindowInsetsAnimation.Callback</code> 来监听 window insets 的高度变化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> editText = findViewById&lt;EditText&gt;(R.id.edit_text_view)<br>       <span class="hljs-keyword">val</span> call = <span class="hljs-keyword">object</span> : WindowInsetsAnimation.Callback(DISPATCH_MODE_CONTINUE_ON_SUBTREE) &#123;<br>           <span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.R)</span><br>           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">               insets: <span class="hljs-type">WindowInsets</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               runningAnimations: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">WindowInsetsAnimation</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">           )</span></span>: WindowInsets &#123;<br>               <span class="hljs-keyword">val</span> navBar = insets.getInsets(WindowInsets.Type.navigationBars())<br>               <span class="hljs-keyword">val</span> ime = insets.getInsets(WindowInsets.Type.ime())<br>               Log.i(<br>                   <span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;ime:&quot;</span> + ime.top +<br>                           <span class="hljs-string">&quot; &quot;</span> + ime.bottom<br>               )<br>               <span class="hljs-keyword">val</span> params = (editText.layoutParams <span class="hljs-keyword">as</span> ViewGroup.MarginLayoutParams)<br>               params.bottomMargin = (ime.bottom - navBar.bottom).coerceAtLeast(<span class="hljs-number">0</span>)<br>               editText.layoutParams = params<br>               <span class="hljs-keyword">return</span> insets<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>在 onProgress 中，获取 ime 的 高度，并设置 输入框 view bottom margin 为 ime 高度 - nav bar高度，这样，输入框就会跟随键盘 弹起 和收起了。可以看到动画效果非常丝滑。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302020246.gif" alt="录屏1"></p><aside>⛳ Android 提供了 WindowCompat 和 ViewCompat API 来对 小于 Android R 版本的 系统来进行兼容。具体实现代码如下所示，但是，经过我的实际测试，以下代码 无法在 低于 Android R 的设备上运行。</aside><p>原因分析： 我在 manifest xml 文件中设置了<br><code>android:windowSoftInputMode=&quot;stateAlwaysHidden|adjustNothing&quot;</code> 属性，影响了低版本拿insets，此时获取到的 insets 为 null。在低版本上，各种SystemUiFlag都会影响到最终的显示效果。这里会有许多兼容性问题，不建议在 低版本机型上使用 windowinsets compat 的方式来监听键盘的高度。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 1. 使内容区域全屏</span><br>WindowCompat.setDecorFitsSystemWindows(window, <span class="hljs-literal">false</span>)<br><br><span class="hljs-comment">// 2. 设置 System bar 透明</span><br>window.statusBarColor = Color.TRANSPARENT<br>window.navigationBarColor = Color.TRANSPARENT<br><br><span class="hljs-comment">// 3. 可能出现视觉冲突的 view 处理 insets</span><br>ViewCompat.setOnApplyWindowInsetsListener(view) &#123; view, windowInsets -&gt;<br>  <span class="hljs-keyword">val</span> insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())<br>  <span class="hljs-comment">// 此处更改的 margin，也可设置 padding，视情况而定</span><br>  view.updateLayoutParams&lt;MarginLayoutParams&gt; &#123;<br>    topMargin = insets.top<br>      leftMargin = insets.left<br>      bottomMargin = insets.bottom<br>      rightMargin = insets.right<br>  &#125;<br>  WindowInsetsCompat.CONSUMED<br>&#125;<br><span class="hljs-keyword">val</span> callback = <span class="hljs-keyword">object</span> : WindowInsetsAnimationCompat.Callback(DISPATCH_MODE_CONTINUE_ON_SUBTREE) &#123;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPrepare</span><span class="hljs-params">(animation: <span class="hljs-type">WindowInsetsAnimationCompat</span>)</span></span> &#123;<br>                <span class="hljs-keyword">super</span>.onPrepare(animation)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStart</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                animation: <span class="hljs-type">WindowInsetsAnimationCompat</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                bounds: <span class="hljs-type">WindowInsetsAnimationCompat</span>.<span class="hljs-type">BoundsCompat</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: WindowInsetsAnimationCompat.BoundsCompat &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStart(animation, bounds)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                insets: <span class="hljs-type">WindowInsetsCompat</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                runningAnimations: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">WindowInsetsAnimationCompat</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: WindowInsetsCompat &#123;<br>                <span class="hljs-keyword">val</span> navBar = insets.getInsets(WindowInsetsCompat.Type.navigationBars())<br>                <span class="hljs-keyword">val</span> ime = insets.getInsets(WindowInsetsCompat.Type.ime())<br>                Log.i(<br>                    <span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;ime:&quot;</span> + ime.top +<br>                            <span class="hljs-string">&quot; &quot;</span> + ime.bottom<br>                )<br>                <span class="hljs-keyword">val</span> params = (editText.layoutParams <span class="hljs-keyword">as</span> ViewGroup.MarginLayoutParams)<br>                params.bottomMargin = (ime.bottom - navBar.bottom).coerceAtLeast(<span class="hljs-number">0</span>)<br>                editText.layoutParams = params<br>                <span class="hljs-keyword">return</span> insets<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onEnd</span><span class="hljs-params">(animation: <span class="hljs-type">WindowInsetsAnimationCompat</span>)</span></span> &#123;<br>                <span class="hljs-keyword">super</span>.onEnd(animation)<br>            &#125;<br>&#125;<br><span class="hljs-keyword">val</span> editText = findViewById&lt;EditText&gt;(R.id.edit_text_view)<br>ViewCompat.setWindowInsetsAnimationCallback(editText, callback)<br></code></pre></td></tr></table></figure><p>总结，针对键盘高度监听的问题，我们可以 根据 android 版本 和机型，做兼容性的处理，例如，判断 android 系统版本，在 Android R 及以上版本上，使用Window Insets Animation 的方式，以获得最佳的 键盘高度监听动画效果。在 Android R 以下版本 或者 类似 华为 三星等奇葩机型上，使用 addOnGlobalLayoutListener 结合 popup window 的方式监听键盘弹起时的高度变化。</p><p>参考：</p><p><a href="https://juejin.cn/post/6892118334762909709">实现边到边的体验 | 让您的软键盘动起来 (一) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7179128712141471802">Android：使用ViewCompat适配软键盘弹出，解决软键盘遮挡布局问题 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844904006343458830">处理视觉冲突 | 手势导航 (二) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7038422081528135687">Android Detail：Window 篇—— WindowInsets 与 fitsSystemWindow - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Android 开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAC 目录不区分大小写问题</title>
    <link href="/2024/06/02/MAC-%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/"/>
    <url>/2024/06/02/MAC-%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在苹果文件系统 <strong>APFS (Apple File System)</strong>  中，默认情况下是不区分大小写的，这意味着文件和文件夹的名称不区分大小写。例如，”Document.txt” 和 “document.txt” 被视为相同的文件。这种行为适用于大多数用户，并且是 macOS 和 iOS 设备的默认设置。</p><p>最近遇到了一个该特性导致的问题，在往 git 仓库提交文件时，两个人分别创建了两个同名的不区分大小写的文件夹，例如是：”Module” 和 “module”，这两个文件夹都被提交到 git 仓库中了，然后，我本地在拉取代码到 Mac 本地时，这两个文件夹中的内容就被合并了，在不区分大小写的 mac 文件系统中，无法区分出这两个文件夹。</p><p>这种情况导致了一些问题，我们的代码编译是在 linux 上进行的，由于 linux 系统是区分大小写的，所以 在 Module 和 module 中的文件 出现了混乱，导致编译失败。</p><p>解决方案：</p><p>在 mac 上新建一个区分大小写的文件系统分区，打开磁盘工具，创建一个区分大小写的磁盘分区。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024Untitled.png" alt="apfs"></p><p>然后拉取源代码到本地，这时，就可以看到有两个不同的 “Module” 和 “module” 目录，然后选择保留其中一个目录，例如，保留 “module” 小写目录，然后移动所有 “Module” 目录中的文件到 “module” 中之后，删除 “Module” 目录，重新提交更改到 git 仓库。</p><p>移动文件的相关指令，到 这两个文件夹的 父目录下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av --remove-source-files Module/ module/<br></code></pre></td></tr></table></figure><p><code>-a</code>：归档模式，递归复制并保持文件属性。</p><p><code>-v</code>：显示详细输出。</p><p><code>--remove-source-files</code>：在同步后删除源目录中的文件。</p><p>这个命令会将源目录中的所有文件移动到目标目录，并在完成后删除源目录中的文件。</p>]]></content>
    
    
    <categories>
      
      <category>开发问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MAC系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客中的图片怎么管理？</title>
    <link href="/2024/06/02/Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%EF%BC%9F/"/>
    <url>/2024/06/02/Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>一般来讲，我们的博客中会有很多的图片，如果都提交到 Hexo 项目中进行发布的话，会导致我们的 Hexo 静态网站项目非常臃肿，极不推荐使用这种方式来管理博客中的图片。</p><p>如果是我们本地写 Markdown 笔记，图片一般会保存到本地目录，如果是在 Notion or 一些云笔记网站上写，图片会上传到它们的服务器进行保存。</p><p>对于 Hexo 博客，这里推荐使用 图床 的方式来进行管理。</p><p>首先，介绍一下 picgo，<strong>PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具。</strong></p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo is Here | PicGo</a></p><p>PicGo 本体支持如下图床：</p><ul><li><code>七牛图床</code> v1.0</li><li><code>腾讯云 COS v4\v5 版本</code> v1.1 &amp; v1.5.0</li><li><code>又拍云</code> v1.2.0</li><li><code>GitHub</code> v1.5.0</li><li><code>SM.MS V2</code> v2.3.0-beta.0</li><li><code>阿里云 OSS</code> v1.6.0</li><li><code>Imgur</code> v1.6.0</li></ul><p>我们可以结合使用 picgo + github，来管理博客中的图片。</p><p>我们选择直接复用 我们托管 Hexo 博客的 github 仓库，也就是 <a href="http://xcxyh.github.io/">xcxyh.github.io</a> 这个仓库，来新建个 image-save 的分支管理图片。</p><p>在 PicGo 中配置：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406021902888.png" alt="Untitled"></p><p>其中，git token 的生成方式 可以参考：<a href="https://www.cnblogs.com/leon-2016/p/9284837.html">github 生成 token 的方法 - 南菜园 - 博客园 (cnblogs.com)</a></p><p>设置完成之后，可以测试上传一张图片，在相册中 复制图片的链接，看是否可以访问。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406021902261.png" alt="Untitled 1"></p><p>结合 Typora 使用：</p><p>当我们成功搭建好图床之后，每次写 Markdown 文档时，都需要先截图，再保存，然后手动打开 Picgo 完成上传，最后将图片地址复制到 Markdown 文档中。</p><p>如何做到更加高效地上传图片到图床呢？</p><p>用 Typora 写笔记，只需要先截图，再粘贴到 Markdown 文档，根据提示直接上传图片，Typora 帮我们自动完成。</p><p>操作为：打开 Typora 的设置，点击图像，按照我给的图片进行设置，替换 PicGo 路径为你当前的安装路径。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406021902052.png" alt="Untitled 2"></p><p>可以点击验证图片上传，验证是否设置成功~~</p><p>之后，我们便可以愉快地用 Hexo 写图文并茂的博客啦~~~~</p>]]></content>
    
    
    <categories>
      
      <category>HEXO 相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笑一笑就好</title>
    <link href="/2024/05/19/%E7%AC%91%E4%B8%80%E7%AC%91%E5%B0%B1%E5%A5%BD/"/>
    <url>/2024/05/19/%E7%AC%91%E4%B8%80%E7%AC%91%E5%B0%B1%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[<p>随手记录的台词、格言、名言、whatever，笑一笑就好。</p><h2 id="中文篇"><a href="#中文篇" class="headerlink" title="中文篇"></a>中文篇</h2><p>选择你所爱的，爱你所选择的。</p><hr><p>没有谁真正重要。</p><hr><p>如果人在职场不持续学习具体的技能，专业的知识，但又想在职场生存下去，就容易搞别的路子，即是对自己有利，能提升自己地位的事。所以，掌握一门技术，在某一方面成为一名专家，不仅是在增长自己的能力，也是在保全自己的人品。</p><hr><p>睡了两小时午觉，感觉灵魂都被修复了。那是一个温暖的梦。</p><hr><p>拥抱变化。</p><hr><p>谎言不会伤人，真相才是快刀。</p><hr><p>要小心那些一无所有的人。</p><hr><p>愤怒，带来冲动。</p><hr><p>人，只有当带上面具，才能卸下伪装。</p><hr><p>正义无法伸张自己。</p><hr><p>人仿佛永远都是空虚的，用什么都填不满。</p><hr><p>有的时候，不要过度去关注、寻找生活的意义，而是要去关注生活本身，去体验，去做，有些地方，我去过，有些事情，我做过，有些东西，拥有过，其实就够了。生活本身在大多数时候就是无意义的，大多数人的生活也是毫无意义的，对于平庸的我们来讲，生活的体验比意义要重要不是吗。</p><hr><p>你什么都想要，你就什么都得不到。</p><hr><p>以斗争求和平则和平存，以妥协求和平则和平亡。</p><hr><p>积极、主动、不怕拒绝、永远保持激情。</p><hr><p>知道和做到中间有巨大的鸿沟，很多人终生无法逾越。</p><hr><p>自律，不是靠意志力来做到的，而是源于你对未来的期望，你的目标，你内心的渴求。</p><hr><p>深入思考、谨慎决定、坚定执行。</p><hr><p>势利就是只对表面现状的附和，不能超越现在，去想象还未发生的事情。</p><hr><p>要去了解一个人是一个什么样的人，首先想到的要聊的话题的应该是他的童年。</p><hr><p>带着审视的目光去读书，多问为什么。</p><hr><p>对于那些在你生命中出现过的，陪你走过一段路的人，要心怀感激。</p><hr><p>未完待续…</p><h2 id="英文篇"><a href="#英文篇" class="headerlink" title="英文篇"></a>英文篇</h2><p>Living with Pain。</p><hr><p>Fear lasts longer than love.</p><hr><p>Every day like it’s your last.</p><hr><p>Be water my friend.</p><hr><p>Kill the boy and let the man be born.</p><hr><p>Good and great are seldom in the same man.</p><hr><p>Not all problems are worth solving.</p><hr><p>All greatness comes from a brave beginning. — cadillac.</p><hr><p><img src="/../img/movie/dogman.png" alt="dogman"></p><hr><p><img src="/../img/movie/bastard.png" alt="bastarden"></p><hr><p>To be continued…</p>]]></content>
    
    
    <categories>
      
      <category>工作之外</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 建站-HelloWorld</title>
    <link href="/2024/05/19/hello-world/"/>
    <url>/2024/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>为什么需要个人博客？</p><p>平时，作为个人记录，使用类似 Notion 的云笔记就足够了，为什么还需要一个个人博客呢，我认为个人博客有两个作用，一个是博客是展示自己的窗口，是对外的，让别人能够更快的了解你。另一个作用就是作为简历的补充，在找工作时，附上个人网站的链接，无论是 hr 还是 面试官，都可以通过个人博客网站快速了解你，这里的信息要比简历丰富，相比于没有博客网站的人更有优势。</p><p>一句话，它是向他人展示自己的窗口，也是简历的一部分。</p><p>Hexo 是一个快速、简洁且高效的博客框架。主要用于搭建静态博客。支持快速方便的将个人博客网站托管在 GitHub Pages 上，GitHub Pages 是一种静态站点托管服务，每个 GitHub 帐户或组织都可以有一个站点。</p><p>部署方式极其简单，只要简单几步，你就可以拥有一个个人网站。也可以参考官方文档搭建：</p><p><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先保证你的电脑上有 node js 和 git 环境。</p><p>这里我推荐 创建两个 git 仓库，一个 git 仓库用来放 hexo 项目和博客 markdown 源文件，一个 git 仓库用于 部署 hexo 静态博客项目。可以将 放 hexo 项目和博客 markdown 源文件的仓库设置为 private 的，将 部署 hexo 的仓库设置为 public 的。</p><p>安装 hexo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install -g hexo<br></code></pre></td></tr></table></figure><p>在想要的路径下新建一个名为 hexo 的文件夹（名字可以随便取），例如我的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">D:\Hexo\hexo-markdown\<br></code></pre></td></tr></table></figure><p>hexo 初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">cd D:\Hexo\hexo-markdown\<br>hexo init<br><span class="hljs-comment">// 注意，先跑 hexo init，这个命令需要在一个空文件夹下运行</span><br>git init<br></code></pre></td></tr></table></figure><p>输入以上命令后，hexo 会自动下载 hexo 项目初始化的文件到当前目录下，其中 _config.yml 为网站的全局配置文件。如何配置这个配置文件，可以看官方文档，或者 config 文件中的注释配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">.<br>├── _config.yml<br>├── <span class="hljs-keyword">package</span>.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><p>关于主题，直接全网搜 hexo 主题，或者去这里<a href="https://hexo.io/themes/">Themes | Hexo</a>挑一个自己顺眼的就行，将主题 下载到 themes 目录下，更改下 配置文件中的 theme 配置名称就行了。这里我选的是 <a href="https://hexo.fluid-dev.com/">Hexo Theme Fluid (fluid-dev.com)</a> 这个主题，按照教程配置也很简单，这里就不介绍了。</p><h1 id="博客生成、预览"><a href="#博客生成、预览" class="headerlink" title="博客生成、预览"></a>博客生成、预览</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo g # 生成<br>hexo s # 启动服务<br></code></pre></td></tr></table></figure><p>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些就是你博客的静态文件，后续需要把这些提交到 GitHub 上。</p><p>hexo s 是开启本地预览服务，打开浏览器访问  <code>localhost:4000</code>  即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故。</p><p>一些常用的 hexo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;postName&quot;</span>   <span class="hljs-comment"># 新建文章</span><br>hexo new page <span class="hljs-string">&quot;pageName&quot;</span> <span class="hljs-comment"># 新建页面</span><br>hexo generate <span class="hljs-comment"># 生成静态页面至public目录</span><br>hexo server <span class="hljs-comment"># 开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br>hexo deploy <span class="hljs-comment"># 将.deploy目录部署到GitHub</span><br>hexo <span class="hljs-built_in">help</span>  <span class="hljs-comment"># 查看帮助</span><br>hexo version  <span class="hljs-comment"># 查看Hexo的版本</span><br>hexo deploy -g  <span class="hljs-comment"># 生成加部署</span><br>hexo server -g  <span class="hljs-comment"># 生成加预览</span><br><span class="hljs-comment"># 命令的简写</span><br>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy<br></code></pre></td></tr></table></figure><p>过程中遇到问题，可以先 hexo clean，再重试。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>首先，在 config 文件中 配置 部署方式，这里我们选择部署到 GitHub Pages 上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;git&quot;</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:xxxxx/xxxxx.github.io.git</span> <span class="hljs-comment"># 写你自己的仓库</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>注意，需要先把 git 推代码的 ssh 配置完成，这样 在 部署时，hexo 会把最新代码推送到 部署仓库。</p><p>部署仓库创建：</p><p>新建一个名为 用户名.github.io  的仓库，比如说，如果你的 GitHub 用户名是 xcxyh，那么你就新建名为  xcxyh.github.io  的仓库，将来你的网站访问地址就是  xcxyh.github.io。仓库名字必须是：username.github.io，其中 username 是你的用户名。</p><p>由此可见，每一个 GitHub 账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>hexo 部署命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><p>直接执行 hexo d 的话一般会报如下错误：</p><p><code>Deployer not found: git</code></p><p>这是因为缺少了一个插件，我们可以通过如下命令安装：</p><p><code>npm install hexo-deployer-git --save</code></p><p>然后输入 hexo d 就会将本次有改动的代码全部提交（PS：这里 hexo 选择的方式是强推到 master 分支）。</p><p>github.io  在大陆的加载速度过慢且延迟过高，可以选择将 个人网站部署在 Coding，可以参考：<a href="https://support.qq.com/products/104149/faqs-more/?id=61222">CODING (qq.com)</a></p><p>部署随机域名的个人网页流程：</p><p>新建团队用户，个人为管理。</p><p>新建 DevOps 项目，取名要与自己的团队名相同。</p><p>之后再左侧边栏中找到持续部署菜单栏，选中静态网站进行立即部署。</p><p>然后修改 配置 _config.xml 中相关 deploy 部分即可。</p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在 hexo 根目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;文章名称&#x27;</span><br></code></pre></td></tr></table></figure><p>hexo 会帮我们在 _posts 下生成相关 md 文件，我们只需要打开这个文件就可以开始写博客文章了，用这个命令的好处是帮我们自动生成了文章创建时间。</p>]]></content>
    
    
    <categories>
      
      <category>HEXO 相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
