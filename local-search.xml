<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Android 构建流程（笔记流）</title>
    <link href="/2024/07/06/Android-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%EF%BC%88%E7%AC%94%E8%AE%B0%E6%B5%81%EF%BC%89/"/>
    <url>/2024/07/06/Android-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%EF%BC%88%E7%AC%94%E8%AE%B0%E6%B5%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Android的Apk构建流程主要包括资源的编译和代码的编译。梳理清楚打包构建过程能够帮助我们理解为什么编译耗时久以及如何去优化。我们可以从以下两个方面去理解Android的Apk打包构建的过程：</p><ul><li>Apk构建步骤</li><li>Apk自动化构建中的Gradle Task</li></ul><h3 id="Apk构建步骤"><a href="#Apk构建步骤" class="headerlink" title="Apk构建步骤"></a>Apk构建步骤</h3><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062110151.png" alt="APK构建"></p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062111331.png" alt="APK打包流程"></p><p>Apk的构建主要包括以下几个步骤：</p><ol><li>资源文件的编译，包括通过aapt工具编译（AndroidManifest.xml，res）等资源，通过AIDL工具处理AIDL文件生成Java文件。</li><li>Java &amp; kotlin 源代码编译。</li><li>代码混淆，以及利用dex 工具将 class 文件编译为 dex 文件。</li><li>通过 apkbuilder &#x2F; zipflinger 生成 apk文件。</li><li>使用zipalign 对齐，提升 mmap 访问apk文件的速度。</li><li>利用 apksigner 对apk文件进行签名。</li></ol><p><strong>资源文件的编译</strong><br>可以分析一下一个Android工程中通常会包括哪些资源文件：</p><ol><li>AndroidManifest.xml</li><li>res&#x2F; 文件夹下的文件</li><li>asset&#x2F; 文件夹下的文件</li></ol><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062111418.png" alt="app文件"></p><p>在编译资源文件时，除了 asset&#x2F; 文件夹下的文件会直接保留之外，xml 与 res&#x2F;下的文件都会通过 aapt2 来编译为二进制文件。</p><p><code>AAPT2</code>（<code>Android Asset Packaging Tool2</code>）是一种构建工具，<code>Android Studio</code> 和 <code>Android Gradle</code> 插件使用它来编译和打包应用的资源。<code>AAPT2</code> 会解析资源、为资源编制索引，并将资源编译为针对 <code>Android</code>平台进行过优化的二进制格式。Android Gradle 插件 3.0.0 及更高版本默认情况下会启用 AAPT2，因此通常不需要自行调用 <code>aapt2</code>。</p><p>其路径位于：<code>android_sdk/build-tools/version/</code>下</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062112525.png" alt="aapt"></p><p>AAPT2 支持通过启用增量编译实现更快的资源编译。这是通过将资源处理拆分为两个步骤来实现的：</p><ul><li><a href="https://developer.android.google.cn/studio/command-line/aapt2?hl=zh-cn#compile">编译</a>：将资源文件编译为二进制格式。</li><li><a href="https://developer.android.google.cn/studio/command-line/aapt2?hl=zh-cn#link">链接</a>：合并所有已编译的文件并将它们打包到一个软件包中。</li></ul><p>这种拆分方式有助于提高增量编译的性能。例如，如果某个文件中有更改，只需要重新编译该文件。</p><p>编译过程：</p><ol><li>针对位于<code>res/values/</code>下的 xml资源文件，会被编译为以 <code>*.arsc.flat</code>作为扩展名的资源表。</li><li>其他资源文件中，其他所有的xml文件都将转换为扩展名为 <code>*.flat</code> 的二进制 XML 文件。而对于png图片，则会被压缩，并采用 <code>*.png.flat</code> 作为扩展名。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">aapt2 compile project_root/module_root/src/main/res/values-en/<br>strings.xml -o compiled/<br>aapt2 compile project_root/module_root/src/main/res/drawable<br>/myImage.png -o compiled/<br><br><span class="hljs-comment"># 生成文件 values-en_strings.arsc.flat 和 drawable_img.png.flat</span><br></code></pre></td></tr></table></figure><p>链接过程：</p><p>AAPT2 输出的文件不是可执行文件，必须在链接阶段添加这些二进制文件作为输入来生成 APK，在链接阶段，AAPT2 会合并在编译阶段生成的所有中间文件（如资源表、二进制 XML 文件和处理过的 PNG 等 .flat文件），并将它们打包成一个 APK。而且，这个过程中还会生成 R.java文件、resources.arsc和ProGuard 规则文件，此时生成的apk 不含 Dex 等源码文件，无法安装到设备使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">aapt2 <span class="hljs-built_in">link</span> -o output.apk<br> -I android_sdk/platforms/android_version/android.jar<br>    compiled/res/values_values.arsc.flat<br>    compiled/res/drawable_img.flat --manifest /path/to/AndroidManifest.xml -v<br></code></pre></td></tr></table></figure><p><a href="http://r.java/">R.java</a> 文件提供资源文件的id进行索引，而 resources.arsc 文件是资源索引表，供在程序运行时根据id索引到具体的资源路径。如下表所示， resources.arsc 保存了id 、name和路径的映射关系。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062112749.png" alt="resources文件"></p><p>resources.arsc 文件的格式：</p><p>文件头：描述整个文件的信息，数据结构为 Restable_header （<a href="https://android.googlesource.com/platform/frameworks/base/+/56a2301/include/androidfw/ResourceTypes.h">ResourceTypes.h</a>）</p><p>全局字符常量池：存放所有的字符串，便于字符资源的复用。</p><p>资源包：多个资源包，系统资源应用资源等。</p><p>AIDL文件是一种用于进程间通信的接口文件，最终还是要生成为java文件，位于<code>android_sdk/build-tools/version/</code>的 aidl 工具 会将 aidl文件编译为java文件。</p><p><strong>Java &amp; kotlin 源代码编译</strong></p><p>Javac 编译 所有Java代码，包括 AIDL生成的java文件，生成 .class文件。kotlinc 编译所有的kotin代码，生成 .class 文件。APT&#x2F;KAPT生成的代码也是位于这个阶段，当注解被标记为 <code>AnnotationTarget.CLASS</code>时，相对应的注解处理器会在该阶段生成对应的java文件和class文件。</p><p><strong>代码混淆 D8</strong></p><p>在 <code>AGP 3.X</code>以后，<code>Google</code> 分别引入 <code>D8</code>编译器和 <code>R8</code>工具作为默认的 <code>DEX</code>编译器和混淆压缩工具。</p><p><code>d8</code>是一种命令行工具，位于<code>android_sdk/build-tools/version/</code>，Android Studio 和 Android Gradle 插件使用该工具来将项目的.class字节码文件编译为在 Android 设备上运行的 DEX 字节码，即<code>dexing</code> 过程。</p><p><code>R8</code>是 <code>ProGuard</code> 的替代工具，用于代码的压缩（<code>shrinking</code>）和混淆（<code>obfuscation</code>）。</p><p>在 <code>AGP3.4.0</code>版本中，<code>R8</code>把 <code>desugaring</code>、<code>shrinking</code>、<code>obfuscating</code>、<code>optimizing</code> 和 <code>dexing</code>都合并到一步进行执行。</p><p>脱糖（<code>desugaring</code>）即在编译阶段将在语法层面一些底层字节码不支持的特性转换为基础的字节码结构，(比如 <code>List</code> 上的泛型脱糖后在字节码层面实际为 <code>Object</code>)，新的语法可以在所有的设备上运行。</p><p>可以在 gradle.properties 中配置相关属性，来禁用D8、R8 和 desugaring等过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Disables R8 for Android Library modules only.</span><br>android.enableR8.libraries = <span class="hljs-literal">false</span><br><span class="hljs-comment"># Disables R8 for all modules.</span><br>android.enableR8 = <span class="hljs-literal">false</span><br><span class="hljs-comment"># Disables desugaring</span><br>android.enableIncrementalDesugaring=<span class="hljs-literal">false</span><br>android.enableDesugar=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>d8还可用于增量构建，<code>d8</code> 在执行增量构建时，会将一些额外的信息存储在 DEX 输出中。随后在完整构建应用时，<code>d8</code>会利用这些信息来正确处理 <code>--main-dex-list</code>选项以及合并 DEX 文件。</p><p><strong>apkbuilder &#x2F; zipflinger 生成 apk</strong></p><p>将<code>manifest</code>文件、<code>resources</code>文件、<code>dex</code>文件、<code>assets</code>文件等等打包成一个压缩包，也就是<code>apk</code>文件。老版本使用 apkbuilder ，在<code>AGP3.6.0</code>之后，使用<code>zipflinger</code>作为默认打包工具来构建<code>APK</code>，以提高构建速度。</p><p><strong>zipalign 对齐</strong></p><p><code>zipalign</code>是一种 zip 归档文件对齐工具，有助于确保归档文件中的所有未压缩文件相对于文件开头对齐。这样一来，您便可直接通过 mmap 访问这些文件，而无需在 RAM 中复制这些数据并减少了应用的内存用量。</p><aside>💡 注意：您必须在构建流程的特定时间点使用 `zipalign`。该时间点取决于您使用的应用签名工具：<ul><li>如果您使用的是 <a href="https://developer.android.google.cn/studio/command-line/apksigner?hl=zh-cn"><strong><code>apksigner</code></strong></a>，则必须在为 APK 文件签名<strong>之前</strong>使用 **<code>zipalign</code>**。如果您在使用 <strong><code>apksigner</code></strong> 为 APK 签名之后对 APK 做出了进一步更改，签名便会失效。</li><li>如果您使用的是 <a href="https://docs.oracle.com/javase/tutorial/deployment/jar/signing.html"><strong><code>jarsigner</code></strong></a>，则必须在为 APK 文件签名<strong>之后</strong>使用 **<code>zipalign</code>**。</aside></li></ul><p>为了实现对齐，<code>zipalign</code>会更改 zip <strong>本地文件标头</strong>部分中 <code>&quot;extra&quot;</code>字段的大小。此过程还会更改 <code>&quot;extra&quot;</code>字段中的现有数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">zipalign -p -f -v 4 infile.apk outfile.apk<br><br>-p 对齐 <br>-f 覆盖输出<br>-v 详细信息<br>4 4字节对齐<br></code></pre></td></tr></table></figure><p>对齐的主要过程是将<code>APK</code>包中所有的资源文件距离文件起始偏移为4字节整数倍，对齐后就可以使用<code>mmap</code>函数读取文件，可以像读取内存一样对普通文件进行操作。</p><p><strong>apksigner 签名</strong></p><p>需要对apk文件进行签名，否则无法安装，实际项目中会有 debug 和release 两种不同的签名文件。<code>jarsigner</code>只能进行<code>v1</code>签名，而<code>apksigner</code>可以进行<code>v2</code>、<code>v3</code>、<code>v4</code>签名。</p><p>详细介绍：<a href="https://juejin.cn/post/7111116047960244254">Android开发应该知道的签名知识！ - 掘金 (juejin.cn)</a></p><p>消息摘要：对数据进行单向hash，得到固定hash值的过程。常见的摘要算法都有 MD5、SHA-1 和 SHA-256，满足 对相同内容多次hash结果一致，且很少发生hash碰撞。</p><p>非对称加密：非对称加密是使用公钥&#x2F;私钥中的公钥来加密明文，然后使用对应的私钥&#x2F;私钥来解密密文的过程。例如 https 通信过程中的非对称加密过程。</p><p>数字证书：由 CA机构颁发的证明公钥的身份的证书。</p><p>Android 中数字签名的生成和普通的数字签名并没有很大的区别。Android主要使用自签名的方式，不需要CA机构颁发的数字证书。</p><p><strong>v1 签名：</strong></p><p>利用<code>META-INFO</code>文件夹中以<code>MF</code>、<code>SF</code>和 <code>RSA</code>为扩展名的三个文件，将<code>apk</code>中除了<code>META-INFO</code>文件夹中的所有文件进行进行摘要写到 <code>META-INFO/MANIFEST.MF</code>；然后计算<code>MANIFEST.MF</code>文件的摘要写到<code>CERT.SF</code>；最后计算<code>CERT.SF</code>的摘要，使用私钥计算签名，将签名和开发者证书写到<code>CERT.RSA</code>。</p><p>v1签名的问题：</p><p>签名校验慢。</p><p><code>META-INFO</code>文件夹不会被签名，存在一定安全隐患</p><p><strong>v2签名：</strong></p><p>Apk本质上为一个压缩包，而压缩包文件格式一般分为三块：文件数据区，中央目录，中央目录结束节。<code>V2</code>要做的就是，在文件中插入一个<code>APK Signing Block</code>，位于中央目录部分之前。</p><h3 id="Apk自动化构建中的Gradle-Task"><a href="#Apk自动化构建中的Gradle-Task" class="headerlink" title="Apk自动化构建中的Gradle Task"></a>Apk自动化构建中的Gradle Task</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt; Configure project :app<br>&gt; Task :app:preBuild UP-TO-DATE<br>&gt; Task :app:preDebugBuild UP-TO-DATE<br>&gt; Task :app:mergeDebugNativeDebugMetadata NO-SOURCE<br>&gt; Task :app:compileDebugAidl NO-SOURCE<br>&gt; Task :app:compileDebugRenderscript NO-SOURCE<br>&gt; Task :app:generateDebugBuildConfig UP-TO-DATE<br>&gt; Task :app:checkDebugAarMetadata UP-TO-DATE<br>&gt; Task :app:generateDebugResValues UP-TO-DATE<br>&gt; Task :app:generateDebugResources UP-TO-DATE<br>&gt; Task :app:mergeDebugResources UP-TO-DATE<br>&gt; Task :app:packageDebugResources UP-TO-DATE<br>&gt; Task :app:parseDebugLocalResources UP-TO-DATE<br>&gt; Task :app:createDebugCompatibleScreenManifests UP-TO-DATE<br>&gt; Task :app:extractDeepLinksDebug UP-TO-DATE<br>&gt; Task :app:processDebugMainManifest UP-TO-DATE<br>&gt; Task :app:processDebugManifest UP-TO-DATE<br>&gt; Task :app:processDebugManifestForPackage UP-TO-DATE<br>&gt; Task :app:processDebugResources UP-TO-DATE<br>&gt; Task :app:compileDebugKotlin UP-TO-DATE<br>&gt; Task :app:javaPreCompileDebug UP-TO-DATE<br>&gt; Task :app:compileDebugJavaWithJavac UP-TO-DATE<br>&gt; Task :app:mergeDebugShaders UP-TO-DATE<br>&gt; Task :app:compileDebugShaders NO-SOURCE<br>&gt; Task :app:generateDebugAssets UP-TO-DATE<br>&gt; Task :app:mergeDebugAssets UP-TO-DATE<br>&gt; Task :app:compressDebugAssets UP-TO-DATE<br>&gt; Task :app:processDebugJavaRes NO-SOURCE<br>&gt; Task :app:mergeDebugJavaResource UP-TO-DATE<br>&gt; Task :app:checkDebugDuplicateClasses UP-TO-DATE<br>&gt; Task :app:desugarDebugFileDependencies UP-TO-DATE<br>&gt; Task :app:mergeExtDexDebug UP-TO-DATE<br>&gt; Task :app:mergeLibDexDebug UP-TO-DATE<br>&gt; Task :app:dexBuilderDebug UP-TO-DATE<br>&gt; Task :app:mergeProjectDexDebug UP-TO-DATE<br>&gt; Task :app:mergeDebugJniLibFolders UP-TO-DATE<br>&gt; Task :app:mergeDebugNativeLibs NO-SOURCE<br>&gt; Task :app:stripDebugDebugSymbols NO-SOURCE<br>&gt; Task :app:validateSigningDebug UP-TO-DATE<br>&gt; Task :app:writeDebugAppMetadata UP-TO-DATE<br>&gt; Task :app:writeDebugSigningConfigVersions UP-TO-DATE<br>&gt; Task :app:packageDebug UP-TO-DATE<br>&gt; Task :app:createDebugApkListingFileRedirect UP-TO-DATE<br>&gt; Task :app:assembleDebug UP-TO-DATE<br><br>BUILD SUCCESSFUL <span class="hljs-keyword">in</span> 571ms<br>31 actionable tasks: 31 up-to-date<br><br>Build Analyzer results available<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash">:app:preBuild UP-TO-DATE    → 空task，锚点<br>:app:preDebugBuild  → 空task，锚点<br>:app:compileDebugAidl NO-SOURCE → 处理AIDL<br>:app:checkDebugManifest → 检查Manifest是否存在<br>:app:compileDebugRenderscript NO-SOURCE → 处理renderscript<br>:app:generateDebugBuildConfig   → 生成 BuildConfig.java<br>:app:mainApkListPersistenceDebug → 生成 app-list.gson<br>:app:generateDebugResValues → 生成resvalue，generated.xml<br>:app:generateDebugResources → 空task，锚点<br>:app:mergeDebugResources    → 合并资源文件<br>:app:createDebugCompatibleScreenManifests   → manifest文件中生成compatible-screens，指定屏幕适配<br>:app:processDebugManifest → 合并manifest.xml文件<br>:app:processDebugResources → aapt打包资源<br>:app:compileDebugKotlin → 编译Kotlin文件<br>:app:prepareLintJar UP-TO-DATE → 拷贝 lint jar包到指定位置<br>:app:generateDebugSources → 空task，锚点<br>:app:javaPreCompileDebug → 生成 annotationProcessors.json 文件<br>:app:compileDebugJavaWithJavac → 编译 java文件<br>:app:compileDebugNdk → 编译ndk<br>:app:compileDebugSources → 空task，锚点<br>:app:mergeDebugShaders → 合并 shader文件<br>:app:compileDebugShaders → 编译 shaders<br>:app:generateDebugAssets → 空task，锚点<br>:app:mergeDebugAssets → 合并 assests文件<br>:app:validateSigningDebug → 验证签名<br>:app:signingConfigWriterDebug → 编写SigningConfig信息<br>:app:checkDebugDuplicateClasses → 检查重复class<br>:app:transformClassesWithDexBuilderForDebug → class打包成dex<br>:app:transformDexArchiveWithExternalLibsDexMergerForDebug → 打包第三方库的dex<br>:app:transformDexArchiveWithDexMergerForDebug → 打包最终的dex<br>:app:mergeDebugJniLibFolders → 合并jni lib 文件<br>:app:transformNativeLibsWithMergeJniLibsForDebug → 合并jnilibs<br>:app:transformNativeLibsWithStripDebugSymbolForDebug → 去掉native lib里的debug符号<br>:app:processDebugJavaRes NO-SOURCE → 处理java res<br>:app:transformResourcesWithMergeJavaResForDebug → 合并java res<br>:app:packageDebug  → 打包apk<br>:app:assembleDebug → 空task，锚点<br>:app:extractProguardFiles → 生成混淆文件<br></code></pre></td></tr></table></figure><p>Android Gradle Plugin源码阅读准备</p><p><a href="https://juejin.cn/column/6963508988642230285">Gradle - renxhui的专栏 - 掘金 (juejin.cn)</a></p><p>Android gradle plugin 的源码的依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">implementation <span class="hljs-string">&quot;com.android.tools.build:gradle:<span class="hljs-variable">$VERSION</span>&quot;</span><br></code></pre></td></tr></table></figure><p>在 gradle 7.0 之前，gradle 的版本和 agp 的版本号不一致，以下是对应关系：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062112400.png" alt="AGP版本对应"></p><p>安利查看 <code>AGP</code> 源码的一个方法，直接在项目依赖对应 <code>AGP</code> 版本即可，不需要手动下载源码</p><p><code>implementation &quot;com.android.tools.build:gradle:7.1.2&quot;</code></p><p>sync 完成之后，才可以看到AGP源码</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062113285.png" alt="gradle"></p><p>全局搜索 AppPlugin.java 类，而不是 AppPlugin.kt 文件，可以看到 <a href="http://com.android.application.properties/">com.android.application.properties</a> 文件中记录的implementation-class对应的实现类。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">implementation-class=com.android.build.gradle.AppPlugin<br></code></pre></td></tr></table></figure><p>BasePlugin.java</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062113274.png" alt="BasePlugin"></p><p>app 构建流程包括：</p><p><code>configureProject</code></p><p><code>configureExtension</code></p><p><code>createTasks</code></p><p><code>createTasksBeforeEvaluate</code></p><p><code>createAndroidTasks</code></p><p>经过代码跟踪，最终到<code>ApplicationTaskManager</code>类中完成了整个打包过程task 的构建。对于源码阅读，只需要在用到时查找某个功能的使用节点时在跟进代码，找到具体位置即可，例如想知道自定义的 tranform 是在哪个task 任务中被执行的，就可以从该入口进入进行查找：TaskManager#createPostCompilationTasks，关于这个方法的注释为：</p><p><code>Creates the post-compilation tasks for the given Variant. These tasks create the dex file from the .class files, plus optional intermediary steps like proguard and jacoco</code></p><p>为给定变体创建编译后任务。<br>这些任务从.class文件创建 dex 文件，以及可选的中间步骤，如 proguard 和 jacoco</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202407062114189.png" alt="tranform Task"></p><p>agp 各个版本 api 变化较大，最新版本甚至都用kotlin 重写了整个流程，但是整个打包的主体流程是不变的。所以，我们只需要选择其中一个版本，分析它打包流程中所对应的各个task 的作用即可。</p><p><strong>参考资料：</strong></p><ul><li>开发者官网：<a href="https://developer.android.google.cn/">Android 开发者  |  Android Developers (google.cn)</a></li><li>AOSP官网：<a href="https://source.android.google.cn/?hl=zh-cn">Android 开源项目  |  Android Open Source Project (google.cn)</a></li><li>构建相关官方文档：<a href="https://developer.android.google.cn/studio/build?hl=zh-cn">配置 build  |  Android 开发者  |  Android Developers (google.cn)</a></li><li>beesX：<a href="https://www.yuque.com/beesx/beesandroid/qqqbuh">Android安装包的打包流程 (yuque.com)</a></li><li>一些博客：<a href="https://juejin.cn/post/7113713363900694565">Android Apk 编译打包流程，了解一下~ - 掘金 (juejin.cn)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>写代码的一些原则（笔记流）</title>
    <link href="/2024/07/06/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%88%E7%AC%94%E8%AE%B0%E6%B5%81%EF%BC%89/"/>
    <url>/2024/07/06/%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%88%E7%AC%94%E8%AE%B0%E6%B5%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我们都曾经瞟一眼自己亲手造成的混乱，决定弃之而不顾，走向新的一天。我们都曾经看到自己的烂程序居然能运行，然后断言能运行的烂程序总比什么都没有强。我们都曾经说过有朝一日再回头清理。当然，在那些日子里，我们都没听过勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）— Clean Code</p></blockquote><p>随着需求的不断增加和变更，业务逻辑越来越复杂，参与开发的人也越来越多，多人协作开发不可避免的就有改动到同一处代码，同一处逻辑的需要，而一但每个人都随意的在同一处地方添加自己的逻辑之后，就会导致代码耦合严重，难以阅读和维护，降低我们每个人的开发效率和开发体验，从而影响甚至是阻碍了新功能的迭代。</p><h1 id="啥叫设计原则"><a href="#啥叫设计原则" class="headerlink" title="啥叫设计原则"></a>啥叫设计原则</h1><p>关于代码中的设计原则有很多，例如一些经典的设计原则 SOLID、KISS、YAGNI、DRY、LOD 等。原则可能看起来非常简单，但是运用到实际中却不是那么容易，这里列举出来，后续可以深入进行学习，这些设计原则，常看常新：</p><blockquote><p>SOLID ：单一职责原则（Single Responsibility Principle）、开闭原则（Open Closed Principle）、里式替换原则（Liskov Substitution Principle）、接口隔离原则（Interface Segregation Principle）和依赖倒置原则（Dependency Inversion Principle）。</p></blockquote><blockquote><p>KISS ：Keep It Simple and Stupid 尽量保持简单。</p></blockquote><blockquote><p>YAGNI : You Ain’t Gonna Need It 不要做过度设计。</p></blockquote><blockquote><p>DRY: Don’t Repeat Yourself 不要重复。</p></blockquote><blockquote><p>LOD : Law of Demeter 不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。（原文是：Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.）</p></blockquote><h2 id="SOLID"><a href="#SOLID" class="headerlink" title="SOLID"></a>SOLID</h2><p>单一职责原则（Single Responsibility Principle），缩写为 SRP：一个类或者模块只负责完成一个职责（或者功能）。不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><p>评价一个类的职责是否足够单一，并没有一个非常明确的、可以量化的标准。可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。</p><p>几个简单的职责不够单一的判断原则：</p><ul><li>类中的代码行数、函数或属性过多。</li><li>类依赖的其他类过多，或者依赖类的其他类过多。</li><li>私有方法过多。</li><li>比较难给类起一个合适名字，很难用一个业务名词概括。</li></ul><p>开闭原则（Open Closed Principle），‘对扩展开放、修改关闭’。</p><p>添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。</p><p>添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。</p><p>在写代码的时候，我们要多花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程。</p><p>里式替换原则（Liskov Substitution Principle），子类对象（object of subtype&#x2F;derived class）能够替换程序（program）中父类对象（object of base&#x2F;parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。</p><p>多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><p>几个违反里式替换原则的例子：</p><ul><li>子类违背父类声明要实现的功能</li><li>子类违背父类对输入、输出、异常的约定</li><li>子类违背父类注释中所罗列的任何特殊说明</li></ul><p>接口隔离原则（Interface Segregation Principle），客户端不应该被强迫依赖它不需要的接口。</p><p>如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><p>函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。</p><p>接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。</p><p>依赖倒置原则（Dependency Inversion Principle），高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>“控制反转”：在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上，添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。</p><p>“依赖注入”：不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。</p><h2 id="KISS、YAGNI"><a href="#KISS、YAGNI" class="headerlink" title="KISS、YAGNI"></a>KISS、YAGNI</h2><p>几个简单的原则：</p><p>不要使用同事可能不懂的技术来实现代码。</p><p>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</p><p>不要过度优化。</p><h2 id="DRY：什么是重复，怎么定义重复"><a href="#DRY：什么是重复，怎么定义重复" class="headerlink" title="DRY：什么是重复，怎么定义重复"></a>DRY：什么是重复，怎么定义重复</h2><p>实现逻辑重复、功能语义重复和代码执行重复。</p><p>实现逻辑重复：代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。</p><p>功能语义重复：代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。</p><p>代码执行重复：相同的代码的实现逻辑重复的执行了两次。</p><p>代码的复用性是评判代码质量的一个非常重要的标准。提高代码可复用性的一些方法：</p><p>减少代码耦合：高度耦合的类或者函数往往移动一点代码，就要牵连到很多其他相关的代码。高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p><p>满足单一职责原则：大而全的类依赖它的代码或者它依赖的代码就会比较多，难以复用。越细粒度的代码，代码的通用性会越好，越容易被复用。</p><p>模块化业务与非业务逻辑分离：越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。</p><p>通用代码下沉：越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。</p><p>继承、多态、抽象、封装：越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p><p>Rule of three：第一次用到某个功能时，你写一个特定的解决方法；第二次又用到的时候，你拷贝上一次的代码；第三次出现的时候，你才着手”抽象化”，写出通用的解决方法。</p><p>这样做有几个理由：</p><p>（1）省事。如果一种功能只有一到两个地方会用到，就不需要在”抽象化”上面耗费时间了。</p><p>（2）容易发现模式。”抽象化”需要找到问题的模式，问题出现的场合越多，就越容易看出模式，从而可以更准确地”抽象化”。</p><h2 id="LOD：Law-of-Demeter"><a href="#LOD：Law-of-Demeter" class="headerlink" title="LOD：Law of Demeter"></a>LOD：Law of Demeter</h2><p>规则一：不该有直接依赖关系的类之间，不要有依赖。</p><p>规则二：有依赖关系的类之间，尽量只依赖必要的接口。</p><p>迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。</p><p>关于LoD，请记住一条：方法中不要使用ChainMethods。chain中某一个方法的改动会导致整个chain受到影响。</p><p>坏的实践：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Amount = customer.orders().last().totals().amount()<br><span class="hljs-comment">// or</span><br>orders = customer.orders()<br>lastOders = orders.last()<br>totals = lastOders.totals()<br>amount = totals.amount()<br></code></pre></td></tr></table></figure><p>LoD如何使用：<br>一个类中的方法只能调用：<br>1、该类中其他实例方法。<br>2、它自己的参数方法。<br>3、它创建对象的方法。<br>4、不要调用全局变量（包括可变对象、可变单例）。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HtmlDownloader</span>&#123;<br>    Html html;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadHtml</span><span class="hljs-params">(Transporter trans, String url)</span>&#123;<br><span class="hljs-keyword">if</span>(checkUrl(url))&#123;<span class="hljs-comment">// ok 自己的实例方法</span><br><span class="hljs-comment">// return</span><br>&#125;<br>rawData = trans.send(uri);<span class="hljs-comment">// ok 参数对象的方法</span><br><span class="hljs-type">Html</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> createHtml(rawData); <span class="hljs-comment">// ok 它创建的对象</span><br>html.save();<span class="hljs-comment">// ok  它创建对象的方法</span><br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkUrl</span><span class="hljs-params">(String url)</span> &#123;<br><span class="hljs-comment">// check</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="细节是魔鬼"><a href="#细节是魔鬼" class="headerlink" title="细节是魔鬼"></a>细节是魔鬼</h1><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>在足够表达其含义的情况下，命名当然是越短越好。可以利用上下文信息来简化命名。</p><p>命名要避免误导。</p><p>命名要可读、可搜索。</p><p>类名和对象名应该是名词或名词短语，方法名应当是动词或动词短语。</p><p>统一命名规则。</p><p>例如对于接口的命名有人习惯于在前面加上“I”，有人习惯于不加 “I”，而是在实现类上加上Impl。这种在项目中最好保持一致。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>在代码无法表达出清晰的意图，而需要补充额外的信息时才需要注释。注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误。实际中我们很难同步修改代码以及代码上的注释，从而无法保证代码和注释始终表达相同的意思。所以尽管需要注释，但是我们也应该要尽量减少注释量。</p><p>坏的注释：</p><ul><li>多余的注释</li><li>废话型注释</li><li>对每个变量名都进行注释</li><li>表达 “是什么”的注释</li><li>每个类上的归属与署名类的注释</li><li>注释掉的代码</li></ul><p>好的注释：</p><ul><li>对代码意图的解释或补充型注释</li><li>警示型注释</li><li>TODO 注释</li></ul><p>注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数越短小越好。一个函数只做一件事。</p><p>将大函数中的代码分割成小的代码块，并保证函数中的语句都要在同一抽象层级上。相同抽象层级的函数应该放到一起。函数中混杂不同抽象层级，往往让人迷惑。</p><p>函数参数：最理想的参数数量是零（零参数函数），其次是一（单参数函数），再次是二（双参数函数），应尽量避免三（三参数函数）。有足够特殊的理由才能用三个以上参数（多参数函数）。函数包含 3、4 个参数的时候还是能接受的，大于等于 5 个的时候，会影响到代码的可读性。</p><p>对于过多参数函数的处理方法：</p><ul><li>考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。</li><li>将函数的参数封装成对象。</li></ul><p>不要用参数来控制函数的逻辑：</p><p>不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。建议将其拆成两个函数，可读性上也要更好。</p><p>函数的嵌套层次过深：最好不要超过两层。</p><p>解决嵌套过深的方法：</p><p>使用编程语言提供的 continue、break、return 关键字，提前退出嵌套。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (digitalEnable &amp;&amp; isDigitalHuman) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>调整执行顺序来减少嵌套：先写异常逻辑，再写正常逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!useNewStrategy) &#123;<br><span class="hljs-literal">null</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>将部分嵌套逻辑封装成函数调用。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由。</p><p>系统应该由许多短小的类而不是少量巨大的类组成。</p><p>依赖磁铁（dependency magnet）类：常量类。我们把所有的常量都定义到一处地方，当该常量类修改时，所有依赖于它的这些其他的类和模块都需要重新编译和部署。</p><p>对象 与数据结构：</p><p>对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数。</p><p>在任何一个复杂系统中，都会有需要添加新数据类型而不是新函数的时候。这时，对象和面向对象就比较适合。另一方面，也会有想要添加新函数而不是数据类型的时候。在这种情况下，过程式代码和数据结构更合适。</p><p>数据结构只简单地拥有公共变量，没有函数，而对象则拥有私有变量和公共函数。</p><p>方法不应调用由任何函数返回的对象的方法。</p><p>DTO是非常有用的结构，尤其是在与数据库通信、或解析套接字传递的消息之类场景中。我们不幸经常发现开发者往这类数据结构中塞进业务规则方法，把这类数据结构当成对象来用。这是不智的行为，因为它导致了数据结构和对象的混杂体。</p><h1 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h1><p>重构绝对不等于将代码拆分到不同的文件中去。</p><p>大型重构的手段有：分层、模块化、解耦、抽象可复用组件等等</p><p>小范围重构的手段：主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。</p><p>持续重构意识更重要。我们要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，代码质量总会在下降，代码总会存在不完美，重构就会持续在进行。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马服如此恶心，如何玩上韩服DNF？</title>
    <link href="/2024/06/30/%E9%A9%AC%E6%9C%8D%E5%A6%82%E6%AD%A4%E6%81%B6%E5%BF%83%EF%BC%8C%E5%A6%82%E4%BD%95%E7%8E%A9%E4%B8%8A%E9%9F%A9%E6%9C%8DDNF%EF%BC%9F/"/>
    <url>/2024/06/30/%E9%A9%AC%E6%9C%8D%E5%A6%82%E6%AD%A4%E6%81%B6%E5%BF%83%EF%BC%8C%E5%A6%82%E4%BD%95%E7%8E%A9%E4%B8%8A%E9%9F%A9%E6%9C%8DDNF%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106765.jpeg" alt="选角色界面"></p><p>最近，国服 DNF 上线，非常火爆，想玩玩看韩服是什么样子的，由于国内环境问题，想玩上韩服DNF 还是要费上一番功夫的。这里记录下 Android 设备是怎么下载DNF 游戏安装包以及注册 韩服 DNF 账号的。</p><p>首先，需要创建一个未绑定任何地区的 google 账号。</p><p>账号注册需要海外手机号，这里使用 wild card 海外手机号 接收注册验证码的功能。指路：<a href="https://wildcard.com.cn/sms">WildCard | 一分钟注册，轻松订阅海外软件服务</a></p><p>注册完成之后，这里，你需要 一个 有 google 三件套 的 android 手机。进入到 google play app，登录刚才 注册的 账号。然后切换到 韩国地区。</p><p>切换到韩国地区的具体方式：</p><ol><li>首先，科学上网选择韩国节点。</li><li>然后清空 google play app 所有数据。</li><li>然后登录刚才注册的账号。</li><li>不要绑定任何信用卡， 一旦绑定就锁区了，就切换不到韩国地区的 应用商店了。</li></ol><p>例如, 想要切换到 韩国地区,下载 DNF 手游：</p><p>第一步, 注册一个全新的 google 账号,</p><p>第二步 , 连接好 韩国节点代理</p><p>第三步,清空 google play store 的app 所有数据,</p><p>第四步,登录google 账号.</p><p>即可搜到 韩国地区的游戏了.</p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106441.jpeg" alt="Google Play App 清空数据" width="300"><p>DNF 在 韩国地区 为 19+ 游戏, 需要 韩国 id 进行实名认证 才可以下载. 或者 下载 DNF 12+ 未成年版本.</p><p>这里，我们直接下载 12+ 版本，或者 你去某宝上买个 id ，认证后下载 19+ 的版本，这两个版本的主要区别是 交易行的限制，其他没区别，而且账号是互通的。体验韩服，下载 12+版本就行了。</p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106929.jpeg" alt="韩服地下城" width="300"><p>登录时，选择使用 google 账号登录。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106834.png" alt="Google 登录"></p><p>这里 下载完成之后，会遇到一个恶心的问题：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106383.png" alt="非法应用"></p><p>这时需要 在 权限设置中，禁用掉 dnf app 获取 手机应用列表的权限：</p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302107272.jpeg" alt="禁用权限" width="300"><p>完成以上步骤之后，连接好 韩国节点，打开 DNF，就可以愉快的游戏了。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302106508.jpeg" alt="游戏界面"></p>]]></content>
    
    
    <categories>
      
      <category>工作之外</category>
      
    </categories>
    
    
    <tags>
      
      <tag>账号问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Keyboard 高度监听实践</title>
    <link href="/2024/06/30/Android-Keyboard-%E9%AB%98%E5%BA%A6%E7%9B%91%E5%90%AC%E5%AE%9E%E8%B7%B5/"/>
    <url>/2024/06/30/Android-Keyboard-%E9%AB%98%E5%BA%A6%E7%9B%91%E5%90%AC%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>最近遇到一个需求，需要输入框布局附着在软键盘上面，随着软键盘的上移下移动画而移动。要做到这一点，需要监听键盘的高度，而且最好是在键盘弹起的时候，每一帧都有一个高度的回调，这样，我们监听键盘高度的变化，对我们的输入框布局做transY动画 ，即可实现 输入框附着在键盘之上随之上下移动的动画效果了。</p><p>想要实现的效果：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302022019.gif" alt="效果图"></p><p>但是，经过对android 键盘高度监听相关方法的了解，发现事情并没有那么简单。</p><p>Android 监听键盘高度 非常复杂。而且，有多种方式可以实现，并且对于不同的 Android 版本，其实现方式也各不相同。而且，由于Android 机型、版本众多，来自不同品牌、不同类型、不同版本的android  手机，相同的代码可能有不同的表现。</p><p>在很早之前，大家都是用 getViewTreeObserver().addOnGlobalLayoutListener  拿到Activity的ContentView，设置<code>contentView.getViewTreeObserver()                 .addOnGlobalLayoutListener(onGlobalLayoutListener);</code></p><p>然后在监听内部再通过 <code>decorView.getWindowVisibleDisplayFrame</code>来获取显示的Rect，再通过 <code>decorView.getBottom() - outRect.bottom</code>的方式来获取高度。或者是 通过 添加一个宽度为0，高度撑满全屏的 PopupWindow 的骚操作来获取键盘的高度，让软键盘弹起的时候，计算PopopWindow移动了多少范围，从而计算软键盘的高度。而其中的关键就是当输入法弹出时， 它会把之前我们创建的那个看不见的弹窗往上挤， 这样我们创建的那个弹窗的位置就变化了，只要获取它底部高度的变化值就可以间接的获取输入法的高度了。</p><p>下面，简单介绍下，在 android 中 ，获取键盘高度的最新方式。在 Android R （Android 11 ，API 30）版本中，提供了 WindowInsets 相关API，新增了<code>WindowInsetsAnimation.Callback</code> 回调方法。 </p><p>什么是 Insets？</p><p>屏幕上除了开发者 app 绘制的内容还有系统的 Insets（嵌入物），Insets 区域负责描述屏幕的哪些部分会与系统 UI 相交。例如导航或状态栏。</p><p>常见的 Insets 有：</p><ul><li><code>STATUS_BAR</code>，用于展示系统时间，电量，wifi 等信息</li><li><code>NAVIGATION_BAR</code>，虚拟导航栏（区别于实体的三大金刚键），形态有三大金刚键导航，手势导航两种。（有些设备形态如 TV 没有导航栏）</li><li><code>IME</code>，软键盘，用于输入文字</li></ul><p>如果绘制的内容出现在了系统 UI 区域内，就可能出现视觉与手势的冲突。可以借助 Insets 把 view 从屏幕边缘向内移动到一个合适的位置。为了防止 App 内容区域与 <code>System bar</code>发生视觉冲突，官方提供了两种 API，<code>WidowInsets</code> 与  <code>fitsSystemWindows</code>。</p><p><strong><code>WidowInsets</code></strong> </p><p><strong>可以通过在自定义 View 中重写 <code>onApplyWindowInsets()</code> 方法或调用 <code>setOnApplyWindowInsetsListener()</code> 来监听 <code>WindowInsets</code> 的变化，通过对 View 添加 <code>margin</code> 或 <code>padding</code> 的方式处理解决冲突</strong>。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">editText.setOnApplyWindowInsetsListener(<span class="hljs-keyword">object</span> : View.OnApplyWindowInsetsListener &#123;<br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onApplyWindowInsets</span><span class="hljs-params">(v: <span class="hljs-type">View</span>, insets: <span class="hljs-type">WindowInsets</span>)</span></span>: WindowInsets &#123;<br>                <span class="hljs-keyword">val</span> statusBar = insets.getInsets(WindowInsets.Type.statusBars())<br>                <span class="hljs-keyword">val</span> navBars = insets.getInsets(WindowInsets.Type.navigationBars())<br>                Log.i(<span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;status bar: <span class="hljs-subst">$&#123;statusBar.bottom&#125;</span>, nav bar: <span class="hljs-subst">$&#123;navBars.bottom&#125;</span>&quot;</span>)<br>                <span class="hljs-keyword">return</span> insets<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><p>如何使用  window insets：( 版本 ≥ API 21 均可使用，windowInsetsCompat则为其兼容版本)</p><ol><li>使用 <code>ViewCompat.getRootWindowInsets(view)</code> 获取 <code>WindowInsets</code></li><li>通过 <code>WindowInsets#getInsets(type)</code> 获取 Insets</li><li>通过 Insets.top 或 Insets.bottom 获取 <code>System bar</code> 高度</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> windowInsetsCompat = ViewCompat.getRootWindowInsets(editText)<br><span class="hljs-keyword">val</span> ime = windowInsetsCompat?.getInsets(WindowInsetsCompat.Type.ime())<br><span class="hljs-keyword">val</span> height = ime?.bottom<br></code></pre></td></tr></table></figure><p><strong><code>fitsSystemWindows</code></strong></p><p><strong><code>SetFitsSystemWindows</code></strong> 是 View 中 API 14 后加入的方法，对应的 xml 属性是 <strong><code>android:fitsSystemWindows</code></strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span><br>    xmlns:app=<span class="hljs-string">&quot;http://schemas.android.com/apk/res-auto&quot;</span><br>    xmlns:tools=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span><br>    android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>    android:layout_height=<span class="hljs-string">&quot;match_parent&quot;</span><br>    **android:fitsSystemWindows=<span class="hljs-string">&quot;true&quot;</span>**<br>    tools:context=<span class="hljs-string">&quot;.MainActivity&quot;</span>&gt;<br>&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;<br></code></pre></td></tr></table></figure><p><strong><code>FitsSystemWindows</code> 的默认行为是：通过 padding 为 <code>System bar</code> 预留出空间。</strong></p><p>关于 <code>fitsSystemWindows</code>：</p><ul><li><code>fitsSystemWindows</code> 是深度优先（我们可以将视图树看成一个 N叉树）的，第一个设置 <code>fitsSystemWindows</code> 的 view 会去消费 insets 并影响视觉。</li><li>开发者在 xml 或 view 初始化设置的 padding 会被<strong>覆盖。</strong></li><li><a href="https://link.juejin.cn/?target=https://developer.android.com/reference/com/google/android/material/appbar/AppBarLayout.html">AppBarLayout</a>，<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/androidx/coordinatorlayout/widget/CoordinatorLayout.html">CoordinatorLayout</a>，<a href="https://link.juejin.cn/?target=https://developer.android.com/reference/androidx/drawerlayout/widget/DrawerLayout.html">DrawerLayout</a> 等 view 会自定义 <code>fitsSystemWindows</code> 的行为。</li></ul><p>有了以上背景知识之后，我们来看如何使用 window insets 来监听键盘高度，首先，设置 setDecorFitsSystemWindows 为 false，来让内容区域全屏，然后去掉 android:fitsSystemWindows&#x3D;”true” （一定要去掉该属性）。设置完该属性后，发现下方内容都被系统的 nav bar 挡住了，出现了视觉冲突。可以使用以下代码来解决内容被系统bar 覆盖的问题。</p><p>首先设置 bar 为透明，然后，通过 setOnApplyWindowInsetsListener 来获取 window insets，获取系统bar 的高度之后，设置相应的padding。</p><p><strong>实现 边到边 (edge-to-edge) 沉浸式效果，并设置对应padding，不让系统bar 遮挡view内容。</strong></p><p>Android R 版本及以上的实现方式：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">//1. 使内容区域全屏</span><br>window.setDecorFitsSystemWindows(<span class="hljs-literal">false</span>)<br> <span class="hljs-comment">// 2. 设置 System bar 透明</span><br>window.statusBarColor = Color.TRANSPARENT<br>window.navigationBarColor = Color.TRANSPARENT<br><span class="hljs-keyword">val</span> rootView = findViewById&lt;View&gt;(R.id.root_container)<br>rootView.setOnApplyWindowInsetsListener &#123; v, insets -&gt;<br><span class="hljs-keyword">val</span> systemBars = insets.getInsets(WindowInsets.Type.systemBars())<br>  <span class="hljs-comment">// 此处更改的 margin，也可设置 padding，视情况而定</span><br>  rootView.updateLayoutParams&lt;ViewGroup.MarginLayoutParams&gt; &#123;<br>     topMargin = systemBars.top<br>     leftMargin = systemBars.left<br>     bottomMargin = systemBars.bottom<br>     rightMargin = systemBars.right<br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-symbol">@setOnApplyWindowInsetsListener</span> insets<br>&#125;<br></code></pre></td></tr></table></figure><p>然后 设置 <code>WindowInsetsAnimation.Callback</code> 来监听 window insets 的高度变化。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">val</span> editText = findViewById&lt;EditText&gt;(R.id.edit_text_view)<br>       <span class="hljs-keyword">val</span> call = <span class="hljs-keyword">object</span> : WindowInsetsAnimation.Callback(DISPATCH_MODE_CONTINUE_ON_SUBTREE) &#123;<br>           <span class="hljs-meta">@RequiresApi(Build.VERSION_CODES.R)</span><br>           <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">               insets: <span class="hljs-type">WindowInsets</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">               runningAnimations: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">WindowInsetsAnimation</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">           )</span></span>: WindowInsets &#123;<br>               <span class="hljs-keyword">val</span> navBar = insets.getInsets(WindowInsets.Type.navigationBars())<br>               <span class="hljs-keyword">val</span> ime = insets.getInsets(WindowInsets.Type.ime())<br>               Log.i(<br>                   <span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;ime:&quot;</span> + ime.top +<br>                           <span class="hljs-string">&quot; &quot;</span> + ime.bottom<br>               )<br>               <span class="hljs-keyword">val</span> params = (editText.layoutParams <span class="hljs-keyword">as</span> ViewGroup.MarginLayoutParams)<br>               params.bottomMargin = (ime.bottom - navBar.bottom).coerceAtLeast(<span class="hljs-number">0</span>)<br>               editText.layoutParams = params<br>               <span class="hljs-keyword">return</span> insets<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>在 onProgress 中，获取 ime 的 高度，并设置 输入框 view bottom margin 为 ime 高度 - nav bar高度，这样，输入框就会跟随键盘 弹起 和收起了。可以看到动画效果非常丝滑。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406302020246.gif" alt="录屏1"></p><aside>⛳ Android 提供了 WindowCompat 和 ViewCompat API 来对 小于 Android R 版本的 系统来进行兼容。具体实现代码如下所示，但是，经过我的实际测试，以下代码 无法在 低于 Android R 的设备上运行。</aside><p>原因分析： 我在 manifest xml 文件中设置了<br><code>android:windowSoftInputMode=&quot;stateAlwaysHidden|adjustNothing&quot;</code> 属性，影响了低版本拿insets，此时获取到的 insets 为 null。在低版本上，各种SystemUiFlag都会影响到最终的显示效果。这里会有许多兼容性问题，不建议在 低版本机型上使用 windowinsets compat 的方式来监听键盘的高度。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 1. 使内容区域全屏</span><br>WindowCompat.setDecorFitsSystemWindows(window, <span class="hljs-literal">false</span>)<br><br><span class="hljs-comment">// 2. 设置 System bar 透明</span><br>window.statusBarColor = Color.TRANSPARENT<br>window.navigationBarColor = Color.TRANSPARENT<br><br><span class="hljs-comment">// 3. 可能出现视觉冲突的 view 处理 insets</span><br>ViewCompat.setOnApplyWindowInsetsListener(view) &#123; view, windowInsets -&gt;<br>  <span class="hljs-keyword">val</span> insets = windowInsets.getInsets(WindowInsetsCompat.Type.systemBars())<br>  <span class="hljs-comment">// 此处更改的 margin，也可设置 padding，视情况而定</span><br>  view.updateLayoutParams&lt;MarginLayoutParams&gt; &#123;<br>    topMargin = insets.top<br>      leftMargin = insets.left<br>      bottomMargin = insets.bottom<br>      rightMargin = insets.right<br>  &#125;<br>  WindowInsetsCompat.CONSUMED<br>&#125;<br><span class="hljs-keyword">val</span> callback = <span class="hljs-keyword">object</span> : WindowInsetsAnimationCompat.Callback(DISPATCH_MODE_CONTINUE_ON_SUBTREE) &#123;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onPrepare</span><span class="hljs-params">(animation: <span class="hljs-type">WindowInsetsAnimationCompat</span>)</span></span> &#123;<br>                <span class="hljs-keyword">super</span>.onPrepare(animation)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onStart</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                animation: <span class="hljs-type">WindowInsetsAnimationCompat</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                bounds: <span class="hljs-type">WindowInsetsAnimationCompat</span>.<span class="hljs-type">BoundsCompat</span></span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: WindowInsetsAnimationCompat.BoundsCompat &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onStart(animation, bounds)<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onProgress</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">                insets: <span class="hljs-type">WindowInsetsCompat</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                runningAnimations: <span class="hljs-type">MutableList</span>&lt;<span class="hljs-type">WindowInsetsAnimationCompat</span>&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">            )</span></span>: WindowInsetsCompat &#123;<br>                <span class="hljs-keyword">val</span> navBar = insets.getInsets(WindowInsetsCompat.Type.navigationBars())<br>                <span class="hljs-keyword">val</span> ime = insets.getInsets(WindowInsetsCompat.Type.ime())<br>                Log.i(<br>                    <span class="hljs-string">&quot;MainActivity&quot;</span>, <span class="hljs-string">&quot;ime:&quot;</span> + ime.top +<br>                            <span class="hljs-string">&quot; &quot;</span> + ime.bottom<br>                )<br>                <span class="hljs-keyword">val</span> params = (editText.layoutParams <span class="hljs-keyword">as</span> ViewGroup.MarginLayoutParams)<br>                params.bottomMargin = (ime.bottom - navBar.bottom).coerceAtLeast(<span class="hljs-number">0</span>)<br>                editText.layoutParams = params<br>                <span class="hljs-keyword">return</span> insets<br>            &#125;<br><br>            <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onEnd</span><span class="hljs-params">(animation: <span class="hljs-type">WindowInsetsAnimationCompat</span>)</span></span> &#123;<br>                <span class="hljs-keyword">super</span>.onEnd(animation)<br>            &#125;<br>&#125;<br><span class="hljs-keyword">val</span> editText = findViewById&lt;EditText&gt;(R.id.edit_text_view)<br>ViewCompat.setWindowInsetsAnimationCallback(editText, callback)<br></code></pre></td></tr></table></figure><p>总结，针对键盘高度监听的问题，我们可以 根据 android 版本 和机型，做兼容性的处理，例如，判断 android 系统版本，在 Android R 及以上版本上，使用Window Insets Animation 的方式，以获得最佳的 键盘高度监听动画效果。在 Android R 以下版本 或者 类似 华为 三星等奇葩机型上，使用 addOnGlobalLayoutListener 结合 popup window 的方式监听键盘弹起时的高度变化。</p><p>参考：</p><p><a href="https://juejin.cn/post/6892118334762909709">实现边到边的体验 | 让您的软键盘动起来 (一) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7179128712141471802">Android：使用ViewCompat适配软键盘弹出，解决软键盘遮挡布局问题 - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/6844904006343458830">处理视觉冲突 | 手势导航 (二) - 掘金 (juejin.cn)</a></p><p><a href="https://juejin.cn/post/7038422081528135687">Android Detail：Window 篇—— WindowInsets 与 fitsSystemWindow - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Android 开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAC 目录不区分大小写问题</title>
    <link href="/2024/06/02/MAC-%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/"/>
    <url>/2024/06/02/MAC-%E7%9B%AE%E5%BD%95%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在苹果文件系统 <strong>APFS (Apple File System)</strong>  中，默认情况下是不区分大小写的，这意味着文件和文件夹的名称不区分大小写。例如，”Document.txt” 和 “document.txt” 被视为相同的文件。这种行为适用于大多数用户，并且是 macOS 和 iOS 设备的默认设置。</p><p>最近遇到了一个该特性导致的问题，在往 git 仓库提交文件时，两个人分别创建了两个同名的不区分大小写的文件夹，例如是：”Module” 和 “module”，这两个文件夹都被提交到 git 仓库中了，然后，我本地在拉取代码到 Mac 本地时，这两个文件夹中的内容就被合并了，在不区分大小写的 mac 文件系统中，无法区分出这两个文件夹。</p><p>这种情况导致了一些问题，我们的代码编译是在 linux 上进行的，由于 linux 系统是区分大小写的，所以 在 Module 和 module 中的文件 出现了混乱，导致编译失败。</p><p>解决方案：</p><p>在 mac 上新建一个区分大小写的文件系统分区，打开磁盘工具，创建一个区分大小写的磁盘分区。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024Untitled.png" alt="apfs"></p><p>然后拉取源代码到本地，这时，就可以看到有两个不同的 “Module” 和 “module” 目录，然后选择保留其中一个目录，例如，保留 “module” 小写目录，然后移动所有 “Module” 目录中的文件到 “module” 中之后，删除 “Module” 目录，重新提交更改到 git 仓库。</p><p>移动文件的相关指令，到 这两个文件夹的 父目录下，执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rsync -av --remove-source-files Module/ module/<br></code></pre></td></tr></table></figure><p><code>-a</code>：归档模式，递归复制并保持文件属性。</p><p><code>-v</code>：显示详细输出。</p><p><code>--remove-source-files</code>：在同步后删除源目录中的文件。</p><p>这个命令会将源目录中的所有文件移动到目标目录，并在完成后删除源目录中的文件。</p>]]></content>
    
    
    <categories>
      
      <category>开发问题记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MAC系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 博客中的图片怎么管理？</title>
    <link href="/2024/06/02/Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%EF%BC%9F/"/>
    <url>/2024/06/02/Hexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%80%8E%E4%B9%88%E7%AE%A1%E7%90%86%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>一般来讲，我们的博客中会有很多的图片，如果都提交到 Hexo 项目中进行发布的话，会导致我们的 Hexo 静态网站项目非常臃肿，极不推荐使用这种方式来管理博客中的图片。</p><p>如果是我们本地写 Markdown 笔记，图片一般会保存到本地目录，如果是在 Notion or 一些云笔记网站上写，图片会上传到它们的服务器进行保存。</p><p>对于 Hexo 博客，这里推荐使用 图床 的方式来进行管理。</p><p>首先，介绍一下 picgo，<strong>PicGo 是一个用于快速上传图片并获取图片 URL 链接的工具。</strong></p><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide/">PicGo is Here | PicGo</a></p><p>PicGo 本体支持如下图床：</p><ul><li><code>七牛图床</code> v1.0</li><li><code>腾讯云 COS v4\v5 版本</code> v1.1 &amp; v1.5.0</li><li><code>又拍云</code> v1.2.0</li><li><code>GitHub</code> v1.5.0</li><li><code>SM.MS V2</code> v2.3.0-beta.0</li><li><code>阿里云 OSS</code> v1.6.0</li><li><code>Imgur</code> v1.6.0</li></ul><p>我们可以结合使用 picgo + github，来管理博客中的图片。</p><p>我们选择直接复用 我们托管 Hexo 博客的 github 仓库，也就是 <a href="http://xcxyh.github.io/">xcxyh.github.io</a> 这个仓库，来新建个 image-save 的分支管理图片。</p><p>在 PicGo 中配置：</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406021902888.png" alt="Untitled"></p><p>其中，git token 的生成方式 可以参考：<a href="https://www.cnblogs.com/leon-2016/p/9284837.html">github 生成 token 的方法 - 南菜园 - 博客园 (cnblogs.com)</a></p><p>设置完成之后，可以测试上传一张图片，在相册中 复制图片的链接，看是否可以访问。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406021902261.png" alt="Untitled 1"></p><p>结合 Typora 使用：</p><p>当我们成功搭建好图床之后，每次写 Markdown 文档时，都需要先截图，再保存，然后手动打开 Picgo 完成上传，最后将图片地址复制到 Markdown 文档中。</p><p>如何做到更加高效地上传图片到图床呢？</p><p>用 Typora 写笔记，只需要先截图，再粘贴到 Markdown 文档，根据提示直接上传图片，Typora 帮我们自动完成。</p><p>操作为：打开 Typora 的设置，点击图像，按照我给的图片进行设置，替换 PicGo 路径为你当前的安装路径。</p><p><img src="https://raw.githubusercontent.com/xcxyh/xcxyh.github.io/image-save/images/2024202406021902052.png" alt="Untitled 2"></p><p>可以点击验证图片上传，验证是否设置成功~~</p><p>之后，我们便可以愉快地用 Hexo 写图文并茂的博客啦~~~~</p>]]></content>
    
    
    <categories>
      
      <category>HEXO 相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笑一笑就好</title>
    <link href="/2024/05/19/%E7%AC%91%E4%B8%80%E7%AC%91%E5%B0%B1%E5%A5%BD/"/>
    <url>/2024/05/19/%E7%AC%91%E4%B8%80%E7%AC%91%E5%B0%B1%E5%A5%BD/</url>
    
    <content type="html"><![CDATA[<p>随手记录的台词、格言、名言、whatever，笑一笑就好。</p><h2 id="中文篇"><a href="#中文篇" class="headerlink" title="中文篇"></a>中文篇</h2><p>选择你所爱的，爱你所选择的。</p><hr><p>没有谁真正重要。</p><hr><p>如果人在职场不持续学习具体的技能，专业的知识，但又想在职场生存下去，就容易搞别的路子，即是对自己有利，能提升自己地位的事。所以，掌握一门技术，在某一方面成为一名专家，不仅是在增长自己的能力，也是在保全自己的人品。</p><hr><p>睡了两小时午觉，感觉灵魂都被修复了。那是一个温暖的梦。</p><hr><p>拥抱变化。</p><hr><p>谎言不会伤人，真相才是快刀。</p><hr><p>要小心那些一无所有的人。</p><hr><p>愤怒，带来冲动。</p><hr><p>人，只有当带上面具，才能卸下伪装。</p><hr><p>正义无法伸张自己。</p><hr><p>人仿佛永远都是空虚的，用什么都填不满。</p><hr><p>有的时候，不要过度去关注、寻找生活的意义，而是要去关注生活本身，去体验，去做，有些地方，我去过，有些事情，我做过，有些东西，拥有过，其实就够了。生活本身在大多数时候就是无意义的，大多数人的生活也是毫无意义的，对于平庸的我们来讲，生活的体验比意义要重要不是吗。</p><hr><p>你什么都想要，你就什么都得不到。</p><hr><p>以斗争求和平则和平存，以妥协求和平则和平亡。</p><hr><p>积极、主动、不怕拒绝、永远保持激情。</p><hr><p>知道和做到中间有巨大的鸿沟，很多人终生无法逾越。</p><hr><p>自律，不是靠意志力来做到的，而是源于你对未来的期望，你的目标，你内心的渴求。</p><hr><p>深入思考、谨慎决定、坚定执行。</p><hr><p>势利就是只对表面现状的附和，不能超越现在，去想象还未发生的事情。</p><hr><p>要去了解一个人是一个什么样的人，首先想到的要聊的话题的应该是他的童年。</p><hr><p>带着审视的目光去读书，多问为什么。</p><hr><p>对于那些在你生命中出现过的，陪你走过一段路的人，要心怀感激。</p><hr><p>未完待续…</p><h2 id="英文篇"><a href="#英文篇" class="headerlink" title="英文篇"></a>英文篇</h2><p>Living with Pain。</p><hr><p>Fear lasts longer than love.</p><hr><p>Every day like it’s your last.</p><hr><p>Be water my friend.</p><hr><p>Kill the boy and let the man be born.</p><hr><p>Good and great are seldom in the same man.</p><hr><p>Not all problems are worth solving.</p><hr><p>All greatness comes from a brave beginning. — cadillac.</p><hr><p><img src="/../img/movie/dogman.png" alt="dogman"></p><hr><p><img src="/../img/movie/bastard.png" alt="bastarden"></p><hr><p>To be continued…</p>]]></content>
    
    
    <categories>
      
      <category>工作之外</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 建站-HelloWorld</title>
    <link href="/2024/05/19/hello-world/"/>
    <url>/2024/05/19/hello-world/</url>
    
    <content type="html"><![CDATA[<p>为什么需要个人博客？</p><p>平时，作为个人记录，使用类似 Notion 的云笔记就足够了，为什么还需要一个个人博客呢，我认为个人博客有两个作用，一个是博客是展示自己的窗口，是对外的，让别人能够更快的了解你。另一个作用就是作为简历的补充，在找工作时，附上个人网站的链接，无论是 hr 还是 面试官，都可以通过个人博客网站快速了解你，这里的信息要比简历丰富，相比于没有博客网站的人更有优势。</p><p>一句话，它是向他人展示自己的窗口，也是简历的一部分。</p><p>Hexo 是一个快速、简洁且高效的博客框架。主要用于搭建静态博客。支持快速方便的将个人博客网站托管在 GitHub Pages 上，GitHub Pages 是一种静态站点托管服务，每个 GitHub 帐户或组织都可以有一个站点。</p><p>部署方式极其简单，只要简单几步，你就可以拥有一个个人网站。也可以参考官方文档搭建：</p><p><a href="https://hexo.io/zh-cn/docs/">文档 | Hexo</a></p><h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>首先保证你的电脑上有 node js 和 git 环境。</p><p>这里我推荐 创建两个 git 仓库，一个 git 仓库用来放 hexo 项目和博客 markdown 源文件，一个 git 仓库用于 部署 hexo 静态博客项目。可以将 放 hexo 项目和博客 markdown 源文件的仓库设置为 private 的，将 部署 hexo 的仓库设置为 public 的。</p><p>安装 hexo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">npm install -g hexo<br></code></pre></td></tr></table></figure><p>在想要的路径下新建一个名为 hexo 的文件夹（名字可以随便取），例如我的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">D:\Hexo\hexo-markdown\<br></code></pre></td></tr></table></figure><p>hexo 初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">cd D:\Hexo\hexo-markdown\<br>hexo init<br><span class="hljs-comment">// 注意，先跑 hexo init，这个命令需要在一个空文件夹下运行</span><br>git init<br></code></pre></td></tr></table></figure><p>输入以上命令后，hexo 会自动下载 hexo 项目初始化的文件到当前目录下，其中 _config.yml 为网站的全局配置文件。如何配置这个配置文件，可以看官方文档，或者 config 文件中的注释配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">.<br>├── _config.yml<br>├── <span class="hljs-keyword">package</span>.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><p>关于主题，直接全网搜 hexo 主题，或者去这里<a href="https://hexo.io/themes/">Themes | Hexo</a>挑一个自己顺眼的就行，将主题 下载到 themes 目录下，更改下 配置文件中的 theme 配置名称就行了。这里我选的是 <a href="https://hexo.fluid-dev.com/">Hexo Theme Fluid (fluid-dev.com)</a> 这个主题，按照教程配置也很简单，这里就不介绍了。</p><h1 id="博客生成、预览"><a href="#博客生成、预览" class="headerlink" title="博客生成、预览"></a>博客生成、预览</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">hexo g # 生成<br>hexo s # 启动服务<br></code></pre></td></tr></table></figure><p>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些就是你博客的静态文件，后续需要把这些提交到 GitHub 上。</p><p>hexo s 是开启本地预览服务，打开浏览器访问  <code>localhost:4000</code>  即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故。</p><p>一些常用的 hexo 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&quot;postName&quot;</span>   <span class="hljs-comment"># 新建文章</span><br>hexo new page <span class="hljs-string">&quot;pageName&quot;</span> <span class="hljs-comment"># 新建页面</span><br>hexo generate <span class="hljs-comment"># 生成静态页面至public目录</span><br>hexo server <span class="hljs-comment"># 开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br>hexo deploy <span class="hljs-comment"># 将.deploy目录部署到GitHub</span><br>hexo <span class="hljs-built_in">help</span>  <span class="hljs-comment"># 查看帮助</span><br>hexo version  <span class="hljs-comment"># 查看Hexo的版本</span><br>hexo deploy -g  <span class="hljs-comment"># 生成加部署</span><br>hexo server -g  <span class="hljs-comment"># 生成加预览</span><br><span class="hljs-comment"># 命令的简写</span><br>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy<br></code></pre></td></tr></table></figure><p>过程中遇到问题，可以先 hexo clean，再重试。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>首先，在 config 文件中 配置 部署方式，这里我们选择部署到 GitHub Pages 上。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">&quot;git&quot;</span><br>  <span class="hljs-attr">repository:</span> <span class="hljs-string">git@github.com:xxxxx/xxxxx.github.io.git</span> <span class="hljs-comment"># 写你自己的仓库</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>注意，需要先把 git 推代码的 ssh 配置完成，这样 在 部署时，hexo 会把最新代码推送到 部署仓库。</p><p>部署仓库创建：</p><p>新建一个名为 用户名.github.io  的仓库，比如说，如果你的 GitHub 用户名是 xcxyh，那么你就新建名为  xcxyh.github.io  的仓库，将来你的网站访问地址就是  xcxyh.github.io。仓库名字必须是：username.github.io，其中 username 是你的用户名。</p><p>由此可见，每一个 GitHub 账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>hexo 部署命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo d<br></code></pre></td></tr></table></figure><p>直接执行 hexo d 的话一般会报如下错误：</p><p><code>Deployer not found: git</code></p><p>这是因为缺少了一个插件，我们可以通过如下命令安装：</p><p><code>npm install hexo-deployer-git --save</code></p><p>然后输入 hexo d 就会将本次有改动的代码全部提交（PS：这里 hexo 选择的方式是强推到 master 分支）。</p><p>github.io  在大陆的加载速度过慢且延迟过高，可以选择将 个人网站部署在 Coding，可以参考：<a href="https://support.qq.com/products/104149/faqs-more/?id=61222">CODING (qq.com)</a></p><p>部署随机域名的个人网页流程：</p><p>新建团队用户，个人为管理。</p><p>新建 DevOps 项目，取名要与自己的团队名相同。</p><p>之后再左侧边栏中找到持续部署菜单栏，选中静态网站进行立即部署。</p><p>然后修改 配置 _config.xml 中相关 deploy 部分即可。</p><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在 hexo 根目录下执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new <span class="hljs-string">&#x27;文章名称&#x27;</span><br></code></pre></td></tr></table></figure><p>hexo 会帮我们在 _posts 下生成相关 md 文件，我们只需要打开这个文件就可以开始写博客文章了，用这个命令的好处是帮我们自动生成了文章创建时间。</p>]]></content>
    
    
    <categories>
      
      <category>HEXO 相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo建站</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
